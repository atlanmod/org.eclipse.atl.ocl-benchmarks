In order to evaluate the gain in performance of the lazy evaluationimplementation of the OCL included in the EMFTVM w.r.t. a greedy evaluationimplementation we have conducted an experimental performance evaluation. Itconsisted in testing, for each different collection type, the performance ofeach collection and iteration operation and compare its time performance withthe time performance of the eager implementation of the standard ATL VirtualMachine (ideally, an evaluation of the lazy OCL evaluation implementation ofEMFTVM against an eager implementation on the same VM would have been preferred,but there is not such an eager implementation available).\begin{figure*}[h]\centering\includegraphics[width=10cm]{figures/producerConsumer}\caption{Producer Consumer Schema}\label{fig:producerConsumer}\end{figure*}The general schema for the evaluation of each operation follows a Producerconsumer pattern (see Figure \ref{fig:producerConsumer}) and is composed, as canbe seen in Figure \ref{fig:producerConsumerOCL} of three elements: 1) a sourcecollection, 2) the operation to test acting as a value producer, and 3) aconsumer that will incrementally (when it applies) request that values generatedby the producer from the source collection.\begin{figure*}[h]\centering\includegraphics[width=10cm]{figures/producerConsumerOCL}\caption{Producer Consumer Instantiated for OCL evaluation}\label{fig:producerConsumerOCL}\end{figure*}We also provide an especial operation, \emph{expensive()}, intended toadd computation complexity to the evaluation process without requiring too largecollections. We have decided to implement a product of a recursive factorial asour \emph{expensive()} operation. We use the product operation inorder to increment the evaluation time for the operation while avoiding the exhaustion of the memory heap due to the recursive calls. Note that for thepurpose of this experimentation, we are not interested in the returned value ofthis operation. We will consider it to return 0 as it is the case for anyfactorial input value greater than 10 due to the overflow of the Integerrepresentation (if used with smaller values of factorial, the expensiveoperation would need to be refactored to return 0 as other values may distortthe results of the tests).\begin{lstlisting}[language=ATL, style=AMMA,label=lst:expensiveOP, caption=expensive() operation] helper context Integer def : expensive() : Integer =	thisModule.factorial(thisModule.expensiveValue)*thisModule.factorial(thisModule.expensiveValue);		helper def : factorial(val: Integer) : Integer =	if(val = 1) then 		1	else		val * thisModule.factorial(val-1)	endif;\end{lstlisting}We provide two source collections. \emph{Numbers(end: Integer)} and\emph{Squares(end:Integer)}. As can be seen in Listings \ref{lst:NumbersOP} and\ref{lst:SquaresOP} they basically create a collection of numbers from 1 to endand a collection of squares from 1 to end. Note that all the operations wepresent here operates on a concrete collection type are thus, refactored to workwith the other collection types in the corresponding tests. Note also that, forthe cases where \emph{select} or \emph{collect} can no be used to add a call tothe expensive operation (this happens when, due to the implementation, a call tocollect or select returns a different operation than the original) we alsoprovide a version of squares, \emph{SquaresE()}, that adds a call to the\emph{expensive()} operation.\begin{lstlisting}[language=ATL, style=AMMA,label=lst:NumbersOP, caption=Numbers() operation] helper def : Numbers(end: Integer) : Sequence(Integer) =	if (end = 1)		then Sequence{1}		else thisModule.squares(end-1)->including(end)	endif;\end{lstlisting}\begin{lstlisting}[language=ATL, style=AMMA,label=lst:SquaresOP, caption=Squares() operation] helper def : squares(end: Integer) : Sequence(Integer) =	if (end = 1)		then Sequence{1}		else thisModule.squares(end-1)->including(end*end)	endif;\end{lstlisting}Our consumer, for operations returning a collection is as shown in listing\ref{lst:takeOP}. For operations returning single values, we will use the greedyoperation \emph{debug()} that prints in console the result of a given operationand thus, makes sure the calculation is performed.The \emph{take(n:Integer, col: Collection(Integer))} operation recursivelybuilds a collection by taking N elements from the input collection. Thissimulates the iterative consumption of the source collection (to which we haveapplied the operation to be tested) allowing us to evaluate the performance ofthe lazy calculation evaluation for different values of N.\begin{lstlisting}[language=ATL, style=AMMA,label=lst:takeOP, caption=take() operation] helper def: take(n: Integer, seq: Sequence(Integer)) : Sequence(Integer) = 	if(n = 1) then		Sequence{1}	else		thisModule.take(n-1,seq)->including(seq->at(n))	endif;-- Alternative implementation with collection as contexthelper context Sequence(Integer) def : take(n:Integer) : Sequence(Integer) = 	if(n = 1) then		Sequence{1}	else		self.takeFromSeq(n-1)->including(self->at(n))	endif;-- Alternative implementation for Sets	helper def: take(n: Integer, seq: Set(Integer)) : Set(Integer) = 	if(n = 1) then		Set{1}	else		let prev:Set(Integer) = thisModule.take(n-1, seq) in			prev->including(seq->any(x|prev->excludes(x)))	endif;	-- Alternative implementation for Sets with collection as contexthelper context Set(Integer) def : takeFromSeq(n:Integer) : Set(Integer) = 	if(n = 1) then		Set{1}	else		let prev:Set(Integer) = self.takeFromSeq(n-1) in			prev->including(self->any(x|prev->excludes(x)))	endif;	\end{lstlisting}\section{Non available operations}Some operations could have not been tested because they are not available in theimplementation of at least one of the VMs. In the following we will list all themissing operations.\subsection{Sequence}\begin{itemize}  \item Max()  \item Reverse()  \item CollectNested()\end{itemize}\subsection{Set}\begin{itemize}  \item Reverse()\end{itemize}\subsection{Bag}\begin{itemize}  \item Intersection()  \item SymmetricDifference()  \item Minus()\end{itemize}\subsection{OrderedSet}  Operations not available in the standard VM\begin{itemize}  \item At() (OrderedSet is implemented as a LinkedHashSet that does not  provide a get operation, preventing an easy an efficient implementation of at())  \item Max()  \item Reverse()\end{itemize}