In order to evaluate the gain in performance of the lazy evaluationimplementation of the OCL included in the EMFTVM w.r.t. a greedy evaluationimplementation we have conducted an experimental performance evaluation. Itconsisted in testing, for each different collection type, the performance ofeach collection and iteration operation and compare its time performance withthe time performance of the eager implementation of the standard ATL VirtualMachine (ideally, an evaluation of the lazy OCL evaluation implementation ofEMFTVM against an eager implementation on the same VM would have been preferred,but there is not such an eager implementation available).\begin{figure*}[h]\centering\includegraphics[width=10cm]{figures/producerConsumer}\caption{Producer Consumer Schema}\label{fig:producerConsumer}\end{figure*}The general schema for the evaluation of each operation follows a Producerconsumer pattern (see Figure \ref{fig:producerConsumer}) and is composed, as canbe seen in Figure \ref{fig:producerConsumerOCL} of three elements: 1) a sourcecollection, 2) the operation to test acting as a value producer, and 3) aconsumer that will incrementally (when it applies) request that values generatedby the producer from the source collection.\begin{figure*}[h]\centering\includegraphics[width=10cm]{figures/producerConsumerOCL}\caption{Producer Consumer Instantiated for OCL evaluation}\label{fig:producerConsumerOCL}\end{figure*}We also provide an especial operation, \emph{expensive()}, intended toadd computation complexity to the evaluation process without requiring too largecollections. We have decided to implement a product of a recursive factorial asour \emph{expensive()} operation. We use the product operation inorder to increment the evaluation time for the operation while avoiding the exhaustion of the memory heap due to the recursive calls. Note that for thepurpose of this experimentation, we are not interested in the returned value ofthis operation. We will consider it to return 0 as it is the case for anyfactorial input value greater than 10 due to the overflow of the Integerrepresentation (if used with smaller values of factorial, the expensiveoperation would need to be refactored to return 0 as other values may distortthe results of the tests).\begin{lstlisting}[language=ATL, style=AMMA,label=lst:expensiveOP, caption=expensive() operation] helper context Integer def : expensive() : Integer =	thisModule.factorial(thisModule.expensiveValue)*thisModule.factorial(thisModule.expensiveValue);		helper def : factorial(val: Integer) : Integer =	if(val = 1) then 		1	else		val * thisModule.factorial(val-1)	endif;\end{lstlisting}We provide two source collections. \emph{Numbers(end: Integer)} and\emph{Squares(end:Integer)}. As can be seen in Listings \ref{lst:NumbersOP} and\ref{lst:SquaresOP} they basically take an EMF collection from a model passed asparameter (namely, a list of numbers called 'Naturals' with natural numbers from0 to 750 and a lisf of numbers called 'Sqaures' with the squares of numbersbetween 0 and 750) to the transformation model and return a sub-collection ofnumbers from 1 to end and a sub-collection of squares from 1 to end. Note thatall the operations we present here operates on a concrete collection type arethus, we have to refactor these two operations to work with the other collectiontypes in the corresponding tests by using the asSet(), asBag() and asasOrderedSet() operations.\begin{lstlisting}[language=ATL, style=AMMA,label=lst:NumbersOP, caption=Numbers() operation] helper def : Numbers(end: Integer) : Sequence(Integer) =	Parameters!Parameter.allInstances()	->select(e|e.name = 'Naturals')	->first().list->subSequence(1,end);\end{lstlisting}\begin{lstlisting}[language=ATL, style=AMMA,label=lst:SquaresOP, caption=Squares() operation] helper def : squares(end: Integer) : Sequence(Integer) =	Parameters!Parameter.allInstances()	->select(e|e.name = 'Squares')	->first().list->subSequence(1,end);\end{lstlisting}Our consumer, for operations returning a collection is as shown in listing\ref{lst:takeOP}. For operations returning single values, we will use the greedyoperation \emph{debug()} that prints in console the result of a given operationand thus, makes sure the calculation is performed.The \emph{take(n:Integer, col: Collection(Integer))} operation recursivelybuilds a collection by taking N elements from the input collection. Thissimulates the iterative consumption of the source collection (to which we haveapplied the operation to be tested) allowing us to evaluate the performance ofthe lazy calculation evaluation for different values of N.\begin{lstlisting}[language=ATL, style=AMMA,label=lst:takeOP, caption=take() operation] helper def: take(n: Integer, seq: Sequence(Integer)) : Sequence(Integer) = 	if(n = 1) then		Sequence{1}	else		let prev:Sequence(Integer) = thisModule.take(n-1, seq) in			prev->including(seq->any(x|prev->excludes(x)))	endif;-- Alternative implementation with collection as contexthelper context Sequence(Integer) def : takeFromSeq(n:Integer):Sequence(Integer) = 	if(n = 1) then		Sequence{1}	else		let prev:Sequence(Integer) = self.takeFromSeq(n-1) in			prev->including(self->any(x|prev->excludes(x)))	endif;\end{lstlisting}\section{Non available operations}Some operations could have not been tested because they are not available in theimplementation of at least one of the VMs. In the following we will list all themissing operations.\subsection{Sequence}\begin{itemize}  \item Max()  \item Reverse()  \item CollectNested()\end{itemize}\subsection{Set}\begin{itemize}  \item Reverse()\end{itemize}\subsection{Bag}\begin{itemize}  \item Intersection()  \item SymmetricDifference()  \item Minus()\end{itemize}\subsection{OrderedSet}  Operations not available in the standard VM\begin{itemize}  \item At() (OrderedSet is implemented as a LinkedHashSet that does not  provide a get operation, preventing an easy an efficient implementation of at())  \item Max()  \item Reverse()\end{itemize}